// Unit tests for analytics utilities

import { analyticsUtils } from '../analytics-utils';
import type { TrendDirection } from '../analytics-table-types';

describe('analyticsUtils', () => {
  // ==============================================================================
  // TREND CALCULATION
  // ==============================================================================

  describe('calculateTrend', () => {
    it('should calculate positive trend correctly', () => {
      const result = analyticsUtils.calculateTrend(80, 70);

      expect(result.current).toBe(80);
      expect(result.previous).toBe(70);
      expect(result.delta).toBe(10);
      expect(result.deltaPercent).toBeCloseTo(14.29, 1);
      expect(result.direction).toBe('up');
    });

    it('should calculate negative trend correctly', () => {
      const result = analyticsUtils.calculateTrend(60, 75);

      expect(result.current).toBe(60);
      expect(result.previous).toBe(75);
      expect(result.delta).toBe(-15);
      expect(result.deltaPercent).toBe(-20);
      expect(result.direction).toBe('down');
    });

    it('should identify stable trend when change is < 0.5%', () => {
      const result = analyticsUtils.calculateTrend(80, 79.6);

      expect(result.current).toBe(80);
      expect(result.previous).toBe(79.6);
      expect(result.delta).toBe(0.4);
      expect(result.deltaPercent).toBeCloseTo(0.5, 1);
      expect(result.direction).toBe('stable');
    });

    it('should handle zero previous value (avoid division by zero)', () => {
      const result = analyticsUtils.calculateTrend(50, 0);

      expect(result.current).toBe(50);
      expect(result.previous).toBe(0);
      expect(result.delta).toBe(50);
      expect(result.deltaPercent).toBe(100);
      expect(result.direction).toBe('up');
    });

    it('should handle zero current and previous values', () => {
      const result = analyticsUtils.calculateTrend(0, 0);

      expect(result.current).toBe(0);
      expect(result.previous).toBe(0);
      expect(result.delta).toBe(0);
      expect(result.deltaPercent).toBe(0);
      expect(result.direction).toBe('stable');
    });

    it('should handle current value of 0 when previous is non-zero', () => {
      const result = analyticsUtils.calculateTrend(0, 50);

      expect(result.current).toBe(0);
      expect(result.previous).toBe(50);
      expect(result.delta).toBe(-50);
      expect(result.deltaPercent).toBe(-100);
      expect(result.direction).toBe('down');
    });
  });

  // ==============================================================================
  // RANKING
  // ==============================================================================

  describe('rankRows', () => {
    interface TestRow {
      id: string;
      score: number;
    }

    const testData: TestRow[] = [
      { id: 'A', score: 90 },
      { id: 'B', score: 85 },
      { id: 'C', score: 90 },
      { id: 'D', score: 70 },
    ];

    it('should rank rows in descending order', () => {
      const ranked = analyticsUtils.rankRows(
        testData,
        (row) => row.score,
        'desc'
      );

      expect(ranked[0].rank).toBe(1);
      expect(ranked[0].data.score).toBe(90);
      expect(ranked[1].rank).toBe(1); // Tied with first
      expect(ranked[1].data.score).toBe(90);
      expect(ranked[2].rank).toBe(3); // Skip rank 2 due to tie
      expect(ranked[2].data.score).toBe(85);
      expect(ranked[3].rank).toBe(4);
      expect(ranked[3].data.score).toBe(70);
    });

    it('should rank rows in ascending order', () => {
      const ranked = analyticsUtils.rankRows(
        testData,
        (row) => row.score,
        'asc'
      );

      expect(ranked[0].rank).toBe(1);
      expect(ranked[0].data.score).toBe(70);
      expect(ranked[1].rank).toBe(2);
      expect(ranked[1].data.score).toBe(85);
      expect(ranked[2].rank).toBe(3);
      expect(ranked[2].data.score).toBe(90);
      expect(ranked[3].rank).toBe(3); // Tied with third
      expect(ranked[3].data.score).toBe(90);
    });

    it('should handle empty array', () => {
      const ranked = analyticsUtils.rankRows([], (row: any) => row.score, 'desc');

      expect(ranked).toEqual([]);
    });

    it('should handle single row', () => {
      const ranked = analyticsUtils.rankRows(
        [{ id: 'A', score: 100 }],
        (row) => row.score,
        'desc'
      );

      expect(ranked.length).toBe(1);
      expect(ranked[0].rank).toBe(1);
    });
  });

  describe('rankRowsWithTrend', () => {
    interface TestRow {
      id: string;
      score: number;
    }

    const currentData: TestRow[] = [
      { id: 'A', score: 90 },
      { id: 'B', score: 85 },
      { id: 'C', score: 70 },
    ];

    const previousData: TestRow[] = [
      { id: 'A', score: 80 },
      { id: 'B', score: 85 },
      { id: 'C', score: 75 },
    ];

    it('should rank rows with trends', () => {
      const ranked = analyticsUtils.rankRowsWithTrend(
        currentData,
        previousData,
        (row) => row.id,
        (row) => row.score,
        'desc'
      );

      expect(ranked.length).toBe(3);

      // Rank 1: A with score 90
      expect(ranked[0].rank).toBe(1);
      expect(ranked[0].data.id).toBe('A');
      expect(ranked[0].trend.current).toBe(90);
      expect(ranked[0].trend.previous).toBe(80);
      expect(ranked[0].trend.direction).toBe('up');

      // Rank 2: B with score 85
      expect(ranked[1].rank).toBe(2);
      expect(ranked[1].data.id).toBe('B');
      expect(ranked[1].trend.current).toBe(85);
      expect(ranked[1].trend.previous).toBe(85);
      expect(ranked[1].trend.direction).toBe('stable');

      // Rank 3: C with score 70
      expect(ranked[2].rank).toBe(3);
      expect(ranked[2].data.id).toBe('C');
      expect(ranked[2].trend.current).toBe(70);
      expect(ranked[2].trend.previous).toBe(75);
      expect(ranked[2].trend.direction).toBe('down');
    });

    it('should handle rows with no previous data', () => {
      const ranked = analyticsUtils.rankRowsWithTrend(
        currentData,
        [],
        (row) => row.id,
        (row) => row.score,
        'desc'
      );

      expect(ranked.length).toBe(3);

      // All trends should be stable (current === previous)
      ranked.forEach((row) => {
        expect(row.trend.current).toBe(row.trend.previous);
        expect(row.trend.direction).toBe('stable');
      });
    });
  });

  // ==============================================================================
  // FILTERING
  // ==============================================================================

  describe('filterRows', () => {
    interface TestRow {
      id: string;
      name: string;
      age: number;
    }

    const testData: TestRow[] = [
      { id: '1', name: 'Alice', age: 25 },
      { id: '2', name: 'Bob', age: 30 },
      { id: '3', name: 'Charlie', age: 35 },
      { id: '4', name: 'David', age: 40 },
    ];

    it('should filter rows by search query', () => {
      const filtered = analyticsUtils.filterRows(testData, 'alice', ['name']);

      expect(filtered.length).toBe(1);
      expect(filtered[0].name).toBe('Alice');
    });

    it('should filter rows case-insensitively', () => {
      const filtered = analyticsUtils.filterRows(testData, 'BOB', ['name']);

      expect(filtered.length).toBe(1);
      expect(filtered[0].name).toBe('Bob');
    });

    it('should filter rows across multiple fields', () => {
      const filtered = analyticsUtils.filterRows(testData, 'charlie', ['name', 'id']);

      expect(filtered.length).toBe(1);
      expect(filtered[0].name).toBe('Charlie');
    });

    it('should return all rows when search query is empty', () => {
      const filtered = analyticsUtils.filterRows(testData, '', ['name']);

      expect(filtered.length).toBe(testData.length);
    });

    it('should return empty array when no matches', () => {
      const filtered = analyticsUtils.filterRows(testData, 'xyz', ['name']);

      expect(filtered.length).toBe(0);
    });
  });

  describe('filterByStatus', () => {
    interface TestRow {
      id: string;
      status: string;
    }

    const testData: TestRow[] = [
      { id: '1', status: 'active' },
      { id: '2', status: 'inactive' },
      { id: '3', status: 'active' },
      { id: '4', status: 'pending' },
    ];

    it('should filter rows by status', () => {
      const filtered = analyticsUtils.filterByStatus(testData, 'status', ['active']);

      expect(filtered.length).toBe(2);
      expect(filtered.every((row) => row.status === 'active')).toBe(true);
    });

    it('should filter rows by multiple statuses', () => {
      const filtered = analyticsUtils.filterByStatus(testData, 'status', ['active', 'pending']);

      expect(filtered.length).toBe(3);
    });

    it('should return all rows when allowed statuses is empty', () => {
      const filtered = analyticsUtils.filterByStatus(testData, 'status', []);

      expect(filtered.length).toBe(testData.length);
    });
  });

  // ==============================================================================
  // PERCENTAGE CALCULATION
  // ==============================================================================

  describe('calculatePercentage', () => {
    it('should calculate percentage correctly', () => {
      expect(analyticsUtils.calculatePercentage(50, 100)).toBe(50);
      expect(analyticsUtils.calculatePercentage(75, 100)).toBe(75);
      expect(analyticsUtils.calculatePercentage(1, 3)).toBeCloseTo(33.33, 2);
    });

    it('should handle zero denominator', () => {
      expect(analyticsUtils.calculatePercentage(50, 0)).toBe(0);
    });

    it('should respect decimal precision', () => {
      expect(analyticsUtils.calculatePercentage(1, 3, 1)).toBe(33.3);
      expect(analyticsUtils.calculatePercentage(1, 3, 3)).toBe(33.333);
    });
  });

  describe('formatPercentage', () => {
    it('should format percentage with decimal', () => {
      expect(analyticsUtils.formatPercentage(75.5)).toBe('75.5%');
      expect(analyticsUtils.formatPercentage(100)).toBe('100.0%');
    });

    it('should respect decimal precision', () => {
      expect(analyticsUtils.formatPercentage(75.556, 2)).toBe('75.56%');
      expect(analyticsUtils.formatPercentage(75.556, 0)).toBe('76%');
    });
  });

  // ==============================================================================
  // DATE UTILITIES
  // ==============================================================================

  describe('calculateDateRange', () => {
    const referenceDate = new Date('2024-01-15');

    it('should calculate day range', () => {
      const range = analyticsUtils.calculateDateRange('day', referenceDate);

      expect(range.startDate).toBe('2024-01-15');
      expect(range.endDate).toBe('2024-01-15');
    });

    it('should calculate week range (last 7 days)', () => {
      const range = analyticsUtils.calculateDateRange('week', referenceDate);

      expect(range.startDate).toBe('2024-01-09');
      expect(range.endDate).toBe('2024-01-15');
    });

    it('should calculate month range (last 30 days)', () => {
      const range = analyticsUtils.calculateDateRange('month', referenceDate);

      expect(range.startDate).toBe('2023-12-17');
      expect(range.endDate).toBe('2024-01-15');
    });

    it('should calculate quarter range (last 90 days)', () => {
      const range = analyticsUtils.calculateDateRange('quarter', referenceDate);

      expect(range.startDate).toBe('2023-10-17');
      expect(range.endDate).toBe('2024-01-15');
    });
  });

  describe('calculatePreviousPeriod', () => {
    it('should calculate previous period correctly', () => {
      const prev = analyticsUtils.calculatePreviousPeriod('2024-01-01', '2024-01-31');

      // 31-day period, so previous should be 31 days before
      expect(prev.startDate).toBe('2023-11-30');
      expect(prev.endDate).toBe('2023-12-31');
    });

    it('should handle single-day period', () => {
      const prev = analyticsUtils.calculatePreviousPeriod('2024-01-15', '2024-01-15');

      expect(prev.startDate).toBe('2024-01-14');
      expect(prev.endDate).toBe('2024-01-14');
    });
  });

  describe('formatDateRange', () => {
    it('should format single day', () => {
      const formatted = analyticsUtils.formatDateRange('2024-01-15', '2024-01-15');

      expect(formatted).toBe('Jan 15, 2024');
    });

    it('should format same month range', () => {
      const formatted = analyticsUtils.formatDateRange('2024-01-01', '2024-01-15');

      expect(formatted).toBe('Jan 1 - 15, 2024');
    });

    it('should format different month range', () => {
      const formatted = analyticsUtils.formatDateRange('2024-01-15', '2024-02-15');

      expect(formatted).toBe('Jan 15, 2024 - Feb 15, 2024');
    });
  });

  // ==============================================================================
  // GROUPING
  // ==============================================================================

  describe('groupByPeriod', () => {
    interface TestRow {
      id: string;
      date: string;
    }

    const testData: TestRow[] = [
      { id: '1', date: '2024-01-15' },
      { id: '2', date: '2024-01-16' },
      { id: '3', date: '2024-01-20' },
      { id: '4', date: '2024-02-01' },
    ];

    it('should group by day', () => {
      const grouped = analyticsUtils.groupByPeriod(testData, 'date', 'day');

      expect(Object.keys(grouped).length).toBe(4);
      expect(grouped['2024-01-15']).toHaveLength(1);
      expect(grouped['2024-01-16']).toHaveLength(1);
    });

    it('should group by month', () => {
      const grouped = analyticsUtils.groupByPeriod(testData, 'date', 'month');

      expect(Object.keys(grouped).length).toBe(2);
      expect(grouped['2024-01']).toHaveLength(3);
      expect(grouped['2024-02']).toHaveLength(1);
    });
  });

  describe('groupBy', () => {
    interface TestRow {
      id: string;
      category: string;
    }

    const testData: TestRow[] = [
      { id: '1', category: 'A' },
      { id: '2', category: 'B' },
      { id: '3', category: 'A' },
      { id: '4', category: 'C' },
    ];

    it('should group by field', () => {
      const grouped = analyticsUtils.groupBy(testData, 'category');

      expect(Object.keys(grouped).length).toBe(3);
      expect(grouped['A']).toHaveLength(2);
      expect(grouped['B']).toHaveLength(1);
      expect(grouped['C']).toHaveLength(1);
    });
  });

  // ==============================================================================
  // PAGINATION
  // ==============================================================================

  describe('paginateArray', () => {
    const testData = Array.from({ length: 100 }, (_, i) => ({ id: i }));

    it('should paginate correctly', () => {
      const page1 = analyticsUtils.paginateArray(testData, 20, 0);

      expect(page1.data.length).toBe(20);
      expect(page1.total).toBe(100);
      expect(page1.hasMore).toBe(true);
      expect(page1.nextOffset).toBe(20);
    });

    it('should handle last page', () => {
      const lastPage = analyticsUtils.paginateArray(testData, 20, 80);

      expect(lastPage.data.length).toBe(20);
      expect(lastPage.hasMore).toBe(false);
      expect(lastPage.nextOffset).toBe(null);
    });

    it('should handle partial last page', () => {
      const partialPage = analyticsUtils.paginateArray(testData, 20, 90);

      expect(partialPage.data.length).toBe(10);
      expect(partialPage.hasMore).toBe(false);
      expect(partialPage.nextOffset).toBe(null);
    });
  });

  // ==============================================================================
  // STATISTICAL HELPERS
  // ==============================================================================

  describe('calculateAverage', () => {
    it('should calculate average correctly', () => {
      expect(analyticsUtils.calculateAverage([10, 20, 30])).toBe(20);
      expect(analyticsUtils.calculateAverage([5, 10, 15, 20])).toBe(12.5);
    });

    it('should handle empty array', () => {
      expect(analyticsUtils.calculateAverage([])).toBe(0);
    });

    it('should handle single value', () => {
      expect(analyticsUtils.calculateAverage([42])).toBe(42);
    });
  });

  describe('calculateMedian', () => {
    it('should calculate median for odd-length array', () => {
      expect(analyticsUtils.calculateMedian([1, 2, 3, 4, 5])).toBe(3);
    });

    it('should calculate median for even-length array', () => {
      expect(analyticsUtils.calculateMedian([1, 2, 3, 4])).toBe(2.5);
    });

    it('should handle empty array', () => {
      expect(analyticsUtils.calculateMedian([])).toBe(0);
    });

    it('should handle unsorted array', () => {
      expect(analyticsUtils.calculateMedian([5, 1, 3, 2, 4])).toBe(3);
    });
  });

  describe('calculateSum', () => {
    it('should calculate sum correctly', () => {
      expect(analyticsUtils.calculateSum([1, 2, 3, 4, 5])).toBe(15);
      expect(analyticsUtils.calculateSum([10, 20, 30])).toBe(60);
    });

    it('should handle empty array', () => {
      expect(analyticsUtils.calculateSum([])).toBe(0);
    });

    it('should handle negative numbers', () => {
      expect(analyticsUtils.calculateSum([10, -5, 3])).toBe(8);
    });
  });
});
